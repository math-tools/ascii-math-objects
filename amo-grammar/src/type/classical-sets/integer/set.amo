type IntSet : RingPlusProd as Z

    + func succ : Z -> Z ,
           pred : Z -> Z

    + alias Z_non_pos : iter_set succ zero ,
            Z_non_neg : iter_set pred zero

    + axiom
        + zero_min_non_pos : forall x in Z_non_pos , zero != succ x
        + zero_max_non_neg : forall x in Z_non_neg , zero != pred x

        + succ_injective : forall x, y in N , succ x = succ y ==> x = y

        + pred_succ_rel  : forall x in N , succ(pred x) = x

        + plus_induc_def : forall x, y in N , succ(x + y) = x + (succ y)
        + zero_absorbent : forall x in N    , zero * x = zero
        + prod_induc_def : forall x, y in N , x * (succ y) = (x * y) + x

        // Z = Z_neg U {0} U Z_pos.
        + non_neg_and_non_pos_is_zero : inter Z_non_neg Z_non_pos = {zero}
        + pos_non_neg_partition       : union Z_non_neg (
                                            union {zero} Z_non_pos
                                        ) = Z

    + desc
        A integer-numbers-like set is a "plus-prod" ring respecting some
        "succ-pred" axioms mixed with some "pos-neg partition" axioms.

    + note
        If amo::''one'' is d√©fined by amo::''one = succ zero'', we have
        amo::''succ x = x + one'' as expected.

        verbatim::
            succ x
            =
            succ(x + zero)
            =
            x + (succ zero)
            =
            x + one


        Now, if amo::''minus_one'' is defined by amo::''minus_one = pred zero'',
        the following steps show that amo::''one + minus_one = zero'' is
        true as expected (remember the ''succ_injective'' axiom).

        verbatim::
            succ(one + minus_one)
            =
            one + (succ minus_one)
            =
            one + (succ(pred zero))
            =
            one + zero
            =
            one
            =
            succ(zero)


        Another expected property is amo::''pred(succ x) = x''.

        verbatim::
            succ(pred(succ x))
            =  { y := succ x }
            succ(pred y)
            =
            y
            =
            succ x


        We also have amo::''pred(x + y) = x + (pred y)''.

        verbatim::
            succ(pred(x + y))
            =
            x + y
            =
            x + succ(pred y)
            =
            succ(x + (pred y))


        Let's finish with amo::''x * (pred y) + x = x * y'' that gives
        amo::''x * minus_one + x = x * zero = zero'' as expected.

        verbatim::
            x * (pred y) + x
            =
            x * (succ (pred y))
            =
            x * y
