/***
Integer number set

A integer-numbers-like set is an "add-prod" ring respecting some "succ-pred"
axioms mixed with some "pos-neg partition" axioms (we could have used the
classical quotient construction from pairs of naturals, but this choice not
reflects the "pred-succ chain" relation between two integers).

note::
    If ''one'' is dÃ©fined by ''one := succ zero'', we have ''succ x = x + one''
    as expected.

    verbatim::
        succ x
        =
        succ (x + zero)
        =
        x + (succ zero)
        =
        x + one


    Now, if ''minus_one'' is defined by ''minus_one := pred zero'', the
    following steps show that ''one + minus_one = zero'' is true as expected
    (remember the ''succ_injective'' axiom).

    verbatim::
        succ (one + minus_one)
        =
        one + (succ minus_one)
        =
        one + (succ (pred zero))
        =
        one + zero
        =
        one
        =
        succ (zero)


    Another expected property is ''pred (succ x) = x''.

    verbatim::
        succ (pred (succ x))
        =  { y := succ x }
        succ (pred y)
        =
        y
        =
        succ x


    We also have ''pred (x + y) = x + (pred y)''.

    verbatim::
        succ (pred (x + y))
        =
        x + y
        =
        x + succ (pred y)
        =
        succ (x + (pred y))


    Let's finish with ''x * (pred y) + x = x * y'' that gives
    ''x * minus_one + x = x * zero = zero'' as expected.

    verbatim::
        x * (pred y) + x
        =
        x * (succ (pred y))
        =
        x * y
***/

type IntSet : DomainAddProd as Z {
  func succ : Z -> Z ,
       pred : Z -> Z

  const PosSet := iter_set_ns succ zero ,
        NegSet := iter_set_ns pred zero

  axiom {
    succ_injective :=
      forall x y in Z ,
      succ x = succ y ==> x = y

    pred_vs_succ :=
      forall x in Z ,
      succ (pred x) = x

    plus_induc_def :=
      forall x y in Z ,
      succ (x + y) = x + (succ y)

    zero_absorbent :=
      forall x in Z ,
      zero * x = zero

    prod_induc_def :=
      forall x y in Z ,
      x * (succ y) = (x * y) + x

    // Z = Z- U {0} U Z.
    no_neg_and_pos :=
      inter PosSet NegSet = {}

    tichotomy_partition :=
      Z = union PosSet (union { zero } NegSet)

    // 0 not "accessible" form Z- and Z.
    zero_min_non_pos :=
      forall x in PosSet ,
      zero != succ x

    zero_max_non_neg :=
      forall x in ZegSet ,
      zero != pred x
  }
}
