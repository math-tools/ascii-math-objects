========
amo-core - TODO
========



> ---------------------------- <

doc

    --> indiquer idée de def constructive un maximum et quand impossible, idée de pouvoir donner une indication : du coup R via ordre complet est mieux que via Dedekin ou Cauchy


> ---------------------------- <

    quotfield à la main va calssical deno et num



    * Several ordered structures

            i) theorem pour IntSet = OrderedMonoidAdd et NatSet = OrderedRingAddProd (même si on ne prouve rien dans ce projet)



    1) Finite sets or multisets qui sont std mais avec une bijection vers ExplicitFiniteSet ???

    1) New types.

        + rational set pas struct quotient car plus simple via deno num
             penser à inj_int

        + The real field ?????
             penser à inj_rat

        + The complex field via RealSet * RealSet : easy!
             penser àinj_real

        + decimal via structure quotient

        + The hamiltonian field via ComplSet * ComplSet : easy!
             penser inj_compl (utile pour de la geo 3d, du coup pas les octonions en std)

        + geometry : voir GEoCoq

        + polynome

        + analyse ???

        + analyse ???

        + Semigroup and semiring ==> group et ring


> ---------------------------- <

tech doc à reprendre !!!!

    ---> les preuves passent dans la doc classique dans la section de toutes les psecs : par exemple, on affiche le code brutalement des specs sans commentaiers (ok car on bosse sur petits fichiers), puis on explique tel ou tel point

    ---> on utilise tnsdoc directement !!!


> ---------------------------- <

doc

    --> indiquer que ce proj sera utilisé pour un idco technique lisible par un humain (avec au passage la possibilité de débsuquer des erreurs par d'autres)

    --> faire des exemples pour la syntaxique

    -> section dédié à l'ensemble des defs !


> ---------------------------- <

+ - * / o : ordre de préécdence imposé mais modifiable !!!

    ---> Comment ? Faore truc flexible ou non ? syst d'api pulique et d'API lourde mais utilisée en interne


> ---------------------------- <

On passe via yaml de config transposable en json, BdD (No) SQL facilment (forunis les outis=ils)

    description
    arités multipls (cf int formerlle vs entre deux borns)
    signatures diff pour dire d'où on part et ou on arrive
    propriété vérifié : penser à sous-classe (par ex, integral linaire en la fonction, chasles sur les borens...)

Ces def yaml servent de base pour les paresuers, ou autres outilsun YAML de doc qui donne les clés obligatoires, celles multipls...etcpenser à proposer y

> ---------------------------- <


program lang

    for_toks_explicit_list

    Inductive list (A:Type) : Untyped :=
        | nil : list A
        | cons : A -> list A -> list A.


    sort : ∀ (l : list nat), {l' : list nat | sorted l' /\ same_elements l l'}




> ---------------------------- <

    1) New directive: ''func_ext'' allows to use very closed implementations for different \signs of one \func.

        + Suppose that ''func succ (n : \N) -> \N {return (\N.succ n)}''.

        + Then, use ''func_ext succ ((n : \N) -> \N) ((n : \Z) -> \Z) with "\Z" for "\N''.

        + Doing that, we have defined ''func succ (n : \Z) -> \Z {return (\Z.succ n)}'' (the ''with'' part is for stupid, but useful, replacements inside the ''{ ... }'' block).
