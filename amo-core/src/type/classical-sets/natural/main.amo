/***
Natural number set

A natural-numbers-like set is an "add" monoid with an additional binary
"prod" operation respecting the Peano axioms with the more precise
''succ_iter_zero_is_N'' axiom instead of the ''predecessor'' and the
inductive axioms suchas to know that any element of ''N'' becomes from
a finite number of successive applications of the ''succ'' function on
''zero''.

note::
    It is easy to see that ''one := succ zero'' has no action on products.

    verbatim::
        x * one
        =
        x * (succ zero)
        =
        (x * zero) + x
        =
        zero x
        =
        x

note::
    ''forall x in N , x!= 0 ==> (exist x_pr in N , x = succ x_pr)'' is
    the ''predecessor'' axiom . We don't use it because it allows the
    existence of non-standard natural sets, without the ''induction''
    axiom, whereas the code ''elt in (iter_set succ zero)'' for the
    special in function avoids non-standard natural sets and gives the
    induction principle.
***/

type NatSet : Set as N {
  var zero : N.InSet

  func succ : N -> N      ,
       add  : N -> N -> N ,
       prod : N -> N -> N

  parse "{x} + {y}" as (add x y)  ,
        "{x} * {y}" as (prod x y)

  fix func in (elt : Untyped) -> \B {
    return (elt in (iter_set succ zero))
  }

  fix func equal (n_1 : N.InSet) -> (n_2 : N.InSet) -> \B {
    return equal_iter succ (zero , zero) (n_1 , n_2)
  }

  axiom {
    zero_min :=
      forall x in N ,
      zero != succ x

    succ_injective :=
      forall x y in N ,
      succ x = succ y ==> x = y

    add_induc_def :=
      forall x y in N ,
      succ (x + y) = x + (succ y)

    zero_absorbent :=
      forall x in N ,
      zero * x = zero

    prod_induc_def :=
      forall x y in N ,
      x * (succ y) = (x * y) + x
  }
}
