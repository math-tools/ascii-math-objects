/***
Some natural-like and fintie structure needs constructions using
iterative application of the same endo-application.

note::
  The suffix ''ns'' in ''iter_set_ns'' stands for "N.o S.tart", but
  the ''start'' element can be achieved when the application is not
  injective.
***/

fix func iter_set (appli : Set -> Set) -> (start : Untyped) -> Set {
  var new_set : Set

  fix func new_set.in (elt : Untyped) -> \B {
    return (
      match elt with
        | start      -> true
        | appli ante -> new_set.in ante
        | _          -> false
    )
  }

  return new_set
}


fix func iter_set_ns (appli : Set -> Set) -> (start : Untyped) -> Set {
  return iter_set appli (appli start)
}


fix func equal_iter (appli : Untyped -> Untyped)
                 -> (start_1 : Untyped, start_2 : Untyped)
                 -> (obj_1 : Untyped, obj_2 : Untyped)
                 -> \B
{
  return (
    match obj_1 , obj_2 with
      | start_1         , start_2         -> true
      | appli pre_obj_1 , appli pre_obj_2 -> equal_iter appli
                                                        (start_1   , start_2)
                                                        (pre_obj_1 , pre_obj_2)
      | _                                 -> false
  )
}


fix func lt_iter (appli : Untyped -> Untyped)
              -> (start : Untyped)
              -> (obj_1 : Untyped, obj_2 : Untyped)
              -> \B
{
  return (
    match obj_1 , obj_2 with
      | start    , start                  -> false
      | _        , start                  -> false
      | start    , _                      -> true
      | appli pre_obj_1 , appli pre_obj_2 -> lt_iter appli
                                                     start
                                                     (pre_obj_1 , pre_obj_2)
      | _                                 -> false
  )
}


fix func lte_iter (appli : Untyped -> Untyped)
               -> (start : Untyped)
               -> (obj_1 : Untyped, obj_2 : Untyped)
               -> \B
{
  return (
    match obj_1 , obj_2 with
      | start           , _               -> true
      | _               , start           -> false
      | appli pre_obj_1 , appli pre_obj_2 -> lte_iter appli
                                                      start
                                                      (pre_obj_1 , pre_obj_2)
      | _                                 -> false
  )
}


fix func iter_ntimes (appli : Untyped -> Untyped)
                  -> (zero_case : Untyped)
                  -> (start : Untyped)
                  -> (nb : Nat)
                  -> Untyped
{
  return (
    match nb with
      | zero  -> zero_case
      | _     -> __iter_ntimes_non_zero__ appli start nb
  )
}

// We must have nb > 0.
fix func __iter_ntimes_non_zero__ (appli : Untyped -> Untyped)
                               -> (start : Untyped)
                               -> (nb : Nat)
                               -> Untyped
{
  return (
    match nb with
      | succ zero   -> start
      | succ pre_nb -> iter_ntimes appli (appli start) pre_nb
  )
}
