/***
???

empty set : {::}

{: obj :}

{: obj_1 || others :} pour récupérer le 1er elt d'écriture et les suivants (au moins un)

{: obj_1 | obj_2 :} pour récupérer le 1er et le 2ième elt d'écriture d'om que deux dans ce cas et pas plus


ensuite on def ope sur les finites set pour que ce qui précède soit OK

parler de COQ

coq::
    ---
    extract = yes
    ---

    Require Import Ensembles.

    Section Ensembles_finis.
      Variable U : Type.
      Inductive Finite : Ensemble U -> Prop :=
        | Empty_is_finite : Finite (Empty_set U)
        | Union_is_finite :
          forall A:Ensemble U,
            Finite A -> forall x:U,
            ~ In U A x -> Finite (Add U A x).
***/

type ExplicitFiniteSet as EFS {
  axiom {
    legal_token_form := (
      match EFS with
        | {::}         -> True
        | {: _ :}      -> True
        | {: _ || _ :} -> True
        | _            -> False
    )
  }

  fix func in (elt : Unspec) -> \B {
    return (_in elt EFS)
  }

  fix func _in (elt : Unspec) (set : Set) -> \B {
    return (
      match set with
        | {: elt :}         -> True
        | {: elt || _ :}    -> True
        | {: _ || others :} -> _in elt {: others :}
        | _                 -> False
    )
  }

  type InSet as Elt {
    axiom {
      elt_of_set := Elt in EFS
    }
  }
}
