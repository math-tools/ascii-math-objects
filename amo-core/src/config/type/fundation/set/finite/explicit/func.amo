/***
???
 on doit construire les versions {: ... :} sinon rien de plus
***/

fix fun add (elt : Untyped) (efset : ExplicitFiniteSet) -> ExplicitFiniteSet {
  if (elt in efset) {
    return efset
  } {
    return match efset
      | {: old_elts :} -> {: elt | old_elts :}
  }
}


fix func diff (efset_1 : ExplicitFiniteSet)
           -> (efset_2 : ExplicitFiniteSet)
           -> ExplicitFiniteSet
{
  var diff_efset : ExplicitFiniteSet := {}

  for_toks_efset efset_1 tok_elt {
    if not (tok_elt in efset_2) {
      add tok_elt diff_efset
    } {}
  }

  return diff_efset
}


fix func union (efset_1 : ExplicitFiniteSet)
            -> (efset_2 : ExplicitFiniteSet)
            -> ExplicitFiniteSet
{
  var union_efset := efset_1

  for_toks_efset efset_2 tok_elt {
    if not (tok_elt in union_efset) {
      add tok_elt union_efset
    } {}
  }

  return union_efset
}


fix func disj_union (efset_1 : ExplicitFiniteSet)
                 -> (efset_2 : ExplicitFiniteSet)
                 -> ExplicitFiniteSet
{
  var disj_union_efset : ExplicitFiniteSet := {}

  for_toks_efset efset_1 tok_elt {
    add (tok_elt, symb_1) disj_union_efset
  }

  for_toks_efset efset_2 tok_elt {
    add (tok_elt, symb_2) disj_union_efset
  }

  return disj_union_efset
}


fix func prod (efset_1 : ExplicitFiniteSet)
           -> (efset_2 : ExplicitFiniteSet)
           -> ExplicitFiniteSet
{
  var prod_efset : ExplicitFiniteSet := {}

  for_toks_efset efset_1 tok_elt_1 {
    for_toks_efset efset_2 tok_elt_2 {
      add (tok_elt_1, tok_elt_2) prod_efset
    }
  }

  return prod_efset
}
