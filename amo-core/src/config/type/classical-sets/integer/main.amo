/***
Integer number set

A integer-numbers-like set is an "add-prod" ring respecting some "succ-pred"
axioms mixed with some "pos-neg partition" axioms (we could have used the
classical quotient construction from pairs of naturals, but this choice not
reflects the "pred-succ chain" relation between two integers).

note::
    ????
    equal ==> PosSet NegSet vide !!! le démontre...

    ???
    aussi zero ni pos ni neg

    If ''one'' is défined by ''one := succ zero'', we have ''succ x = x + one''
    as expected.

    verbatim::
        succ x
        =
        succ (x + zero)
        =
        x + (succ zero)
        =
        x + one


    Now, if ''minus_one'' is defined by ''minus_one := pred zero'', the
    following steps show that ''one + minus_one = zero'' is true as expected
    (remember the ''succ_injective'' axiom).

    verbatim::
        succ (one + minus_one)
        =
        one + (succ minus_one)
        =
        one + (succ (pred zero))
        =
        one + zero
        =
        one
        =
        succ (zero)


    Another expected property is ''pred (succ x) = x''.

    verbatim::
        succ (pred (succ x))
        =  { y := succ x }
        succ (pred y)
        =
        y
        =
        succ x


    We also have ''pred (x + y) = x + (pred y)''.

    verbatim::
        succ (pred (x + y))
        =
        x + y
        =
        x + succ (pred y)
        =
        succ (x + (pred y))


    Let's finish with ''x * (pred y) + x = x * y'' that gives
    ''x * minus_one + x = x * zero = zero'' as expected.

    verbatim::
        x * (pred y) + x
        =
        x * (succ (pred y))
        =
        x * y
***/

type IntSet : DomainAddProd as Z {
  var zero : Z.InSet

  func succ : Z -> Z      ,
       pred : Z -> Z      ,
       add  : Z -> Z -> Z ,
       prod : Z -> Z -> Z

  with (x y : Z.InSet)
  parse "{x} + {y}" as (add x y)  ,
        "{x} * {y}" as (prod x y)

  const PosSet := iter_set_ns succ zero ,
        NegSet := iter_set_ns pred zero

  fix func in (elt : Untyped) -> \B {
    return (
      elt = zero
      or
      elt in (union PosSet NegSet)
    )
  }

  fix func inj_nat (elt : NatSet.InSet) -> InSet {
    return (
// Typing imposes that left ojects live in ''NatSet'', whereas
// the right ones live in ''IntSet'', so ''zero -> zero'' is
// a shortcut for ''NatSet.zero -> IntSet.zero'', and similarly
// the 2nd line uses a shortcut.
      match elt with
        | zero   -> zero
        | succ p -> succ (inj_nat p)
    )
  }

  axiom {
    // pred and succ
    succ_injective :=
      forall x y in Z ,
      succ x = succ y ==> x = y

    pred_vs_succ :=
      forall x in Z ,
      succ (pred x) = x

    // add and prod
    add_induc_def :=
      forall x y in Z ,
      succ (x + y) = x + (succ y)

    zero_absorbent :=
      forall x in Z ,
      zero * x = zero

    prod_induc_def :=
      forall x y in Z ,
      x * (succ y) = (x * y) + x
  }
}
