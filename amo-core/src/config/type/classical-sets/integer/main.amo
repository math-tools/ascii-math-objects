/***
Integer number set

A integer-numbers-like set is an "add-prod" ring respecting some "succ-pred"
axioms mixed with some "pos-neg partition" axioms (we could have used the
classical quotient construction from pairs of naturals, but this choice not
reflects the "pred-succ chain" relation between two integers).

note::
    ????
    equal ==> PosSet NegSet vide !!! le démontre...

    ???
    aussi zero ni pos ni neg

    If ''one'' is défined by ''one := succ zero'', we have ''succ x = x + one''
    as expected.

    verbatim::
        succ x
        =
        succ (x + zero)
        =
        x + (succ zero)
        =
        x + one


    Now, if ''minus_one'' is defined by ''minus_one := pred zero'', the
    following steps show that ''one + minus_one = zero'' is true as expected
    (remember the ''succ_injective'' axiom).

    verbatim::
        succ (one + minus_one)
        =
        one + (succ minus_one)
        =
        one + (succ (pred zero))
        =
        one + zero
        =
        one
        =
        succ (zero)


    Another expected property is ''pred (succ x) = x''.

    verbatim::
        succ (pred (succ x))
        =  { y := succ x }
        succ (pred y)
        =
        y
        =
        succ x


    We also have ''pred (x + y) = x + (pred y)''.

    verbatim::
        succ (pred (x + y))
        =
        x + y
        =
        x + succ (pred y)
        =
        succ (x + (pred y))


    Let's finish with ''x * (pred y) + x = x * y'' that gives
    ''x * minus_one + x = x * zero = zero'' as expected.

    verbatim::
        x * (pred y) + x
        =
        x * (succ (pred y))
        =
        x * y
***/

type IntSet : DomainAddProd as Z {
  var zero : Z.InSet

  func succ : Z -> Z      ,
       pred : Z -> Z      ,
       add  : Z -> Z -> Z ,
       prod : Z -> Z -> Z

  with (x y : Z.InSet) in
  parse "{x} + {y}" as (add x y)  ,
        "{x} * {y}" as (prod x y)

  const PosSet := iter_set_ns succ zero ,
        NegSet := iter_set_ns pred zero

  fix func in (elt : Unspec) -> \B {
    return (
      elt = zero
      or
      elt in (union PosSet NegSet)
    )
  }

  axiom {
    // pred and succ
    succ_injective :=
      forall x y in Z ,
      succ x = succ y ==> x = y

    pred_vs_succ :=
      forall x in Z ,
      succ (pred x) = x

    // add and prod
    add_induc_def :=
      forall x y in Z ,
      succ (x + y) = x + (succ y)

    zero_absorbent :=
      forall x in Z ,
      zero * x = zero

    prod_induc_def :=
      forall x y in Z ,
      x * (succ y) = (x * y) + x
  }

  fix func cano_inj (elt : NatSet.InSet) -> InSet {
    return (
// Typing imposes that left objects live in ''NatSet'', whereas
// the right ones live in ''IntSet'', so ''zero -> zero'' is
// a shortcut for ''NatSet.zero -> IntSet.zero'', and similarly
// the 2nd line uses a shortcut.
      match elt with
        | zero   -> zero
        | succ p -> succ (cano_inj p)
    )
  }


  fix func oppo (n : Z.InSet) -> Z.InSet {
    return (
      match n
        | zero   -> zero
        | succ p -> pred (oppo p)
        | pred p -> succ (oppo p)
      )
    }
  }


  fix func lt (n_1 : Z.InSet) -> (n_2 : Z.InSet) -> \B {
    return (
      match n_1 in Z.PosSet , n_2 in Z.PosSet with
// Positive integers are "like natural numbers".
        | true  , true  -> lt_iter succ zero (n_1, n_2)
// Non positive integers are "like opposite of natural numbers".
        | false , false -> lt_iter pred zero (n_2, n_1)
// Quick case (n_1 <= 0) < (n_2 > 0).
        | false , true  -> true
// Bad case (n_1 > 0) > (n_2 <= 0) remains.
        | _             -> false
      )
    }
  }


  type_ext IntSet : TotalOrderedDomainAddProd {
    var id_add  := Z.zero ,
        id_prod := Z.InSet

    func op_add  := Z.add  ,
         inv_add := Z.oppo ,
         op_prod := Z.prod ,
         lt      := Z.lt
  }
}
